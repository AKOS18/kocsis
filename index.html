<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Endless Aut√≥verseny - Ultimate</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  width: 100%;
  height: 100%;
  background: #111;
  color: #fff;
  font-family: 'Arial', sans-serif;
  overflow: hidden;
  touch-action: none;
}

#game {
  display: block;
  margin: auto;
  background: #000;
}

.overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 10;
  padding: 20px;
  text-align: center;
  backdrop-filter: blur(5px);
}

#hud {
  position: absolute;
  top: 15px;
  left: 15px;
  font-size: clamp(14px, 2vw, 18px);
  background: rgba(0, 0, 0, 0.7);
  padding: 12px 18px;
  border-radius: 10px;
  z-index: 5;
  border: 2px solid rgba(255, 255, 255, 0.2);
  min-width: min(280px, 90vw);
  max-width: 90vw;
  word-wrap: break-word;
}

#controls {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  padding: 15px;
  border-radius: 10px;
  font-size: clamp(12px, 1.5vw, 14px);
  text-align: center;
  border: 2px solid rgba(255, 255, 255, 0.2);
  width: 90%;
  max-width: 600px;
}

#shopBtn {
  position: absolute;
  right: max(10px, 1vw);
  top: 50%;
  transform: translateY(-50%);
  font-size: clamp(16px, 3vw, 24px);
  padding: clamp(8px, 1.5vw, 12px) clamp(12px, 2vw, 20px);
  background: linear-gradient(to bottom, #2ecc71, #27ae60);
  border: none;
  border-radius: 10px;
  color: white;
  cursor: pointer;
  z-index: 5;
  transition: all 0.3s;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  white-space: nowrap;
}

#shopBtn:hover {
  background: linear-gradient(to bottom, #27ae60, #219653);
  transform: translateY(-50%) scale(1.05);
}

button {
  padding: clamp(10px, 2vw, 12px) clamp(16px, 3vw, 24px);
  margin: clamp(6px, 1vw, 8px);
  font-size: clamp(16px, 2vw, 18px);
  background: linear-gradient(to bottom, #3498db, #2980b9);
  border: none;
  border-radius: 8px;
  color: white;
  cursor: pointer;
  transition: all 0.3s;
  min-width: min(200px, 80vw);
  font-weight: bold;
}

button:hover {
  background: linear-gradient(to bottom, #2980b9, #1c6ea4);
  transform: scale(1.05);
}

button:active {
  transform: scale(0.98);
}

select, input {
  padding: clamp(8px, 1.5vw, 10px);
  margin: clamp(8px, 1.5vw, 10px);
  font-size: clamp(14px, 2vw, 16px);
  border-radius: 6px;
  border: 2px solid #3498db;
  background: #222;
  color: white;
  min-width: min(200px, 80vw);
  max-width: 90vw;
}

h1, h2 {
  margin-bottom: clamp(15px, 3vw, 20px);
  color: #3498db;
  text-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

h1 {
  font-size: clamp(28px, 6vw, 42px);
  margin-bottom: clamp(8px, 2vw, 10px);
  background: linear-gradient(to right, #3498db, #2ecc71);
  -webkit-text-fill-color: transparent;
  padding: 0 clamp(10px, 3vw, 20px);
  text-align: center;
}

h2 {
  font-size: clamp(24px, 4vw, 32px);
  padding: 0 clamp(10px, 3vw, 20px);
}

p {
  margin: clamp(8px, 2vw, 10px);
  max-width: min(600px, 90vw);
  line-height: 1.5;
  font-size: clamp(14px, 2vw, 16px);
  padding: 0 clamp(10px, 3vw, 20px);
}

label {
  margin-top: clamp(10px, 2vw, 15px);
  font-size: clamp(16px, 2.5vw, 18px);
  display: block;
}

.shop-item {
  background: rgba(30, 30, 40, 0.9);
  padding: clamp(12px, 2vw, 15px);
  margin: clamp(8px, 1.5vw, 10px);
  border-radius: 10px;
  width: min(300px, 90vw);
  border: 2px solid rgba(52, 152, 219, 0.5);
}

.shop-item h3 {
  color: #f39c12;
  margin-bottom: clamp(6px, 1vw, 8px);
  font-size: clamp(16px, 2.5vw, 18px);
}

.shop-item p {
  margin: clamp(4px, 0.8vw, 5px) 0;
  font-size: clamp(12px, 1.8vw, 14px);
}

.upgrade-bar {
  width: 100%;
  height: clamp(10px, 1.5vw, 12px);
  background: #333;
  border-radius: 6px;
  margin: clamp(6px, 1vw, 8px) 0;
  overflow: hidden;
}

.upgrade-fill {
  height: 100%;
  background: linear-gradient(to right, #2ecc71, #f1c40f);
  border-radius: 6px;
  transition: width 0.5s;
}

.stats {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: clamp(10px, 2vw, 15px);
  margin: clamp(15px, 3vw, 20px);
  width: 100%;
  max-width: 90vw;
}

.stat {
  background: rgba(0, 0, 0, 0.6);
  padding: clamp(12px, 2vw, 15px);
  border-radius: 10px;
  min-width: min(150px, 40vw);
  flex: 1;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

#pauseBtn {
  position: absolute;
  top: clamp(10px, 2vw, 20px);
  right: clamp(10px, 2vw, 20px);
  font-size: clamp(20px, 3vw, 28px);
  padding: clamp(8px, 1.5vw, 10px) clamp(12px, 2vw, 15px);
  background: rgba(52, 152, 219, 0.9);
  border-radius: 8px;
  z-index: 5;
  border: none;
  color: white;
  cursor: pointer;
  transition: all 0.3s;
  white-space: nowrap;
}

#pauseBtn:hover {
  background: rgba(41, 128, 185, 0.9);
  transform: scale(1.1);
}

#pauseBtn.paused {
  background: rgba(46, 204, 113, 0.9);
}

#speedometer {
  position: absolute;
  top: clamp(10px, 2vw, 20px);
  right: clamp(80px, 12vw, 120px);
  background: rgba(0, 0, 0, 0.7);
  padding: clamp(8px, 1.5vw, 10px) clamp(12px, 2vw, 15px);
  border-radius: 10px;
  font-size: clamp(14px, 2vw, 18px);
  border: 2px solid #e74c3c;
  min-width: min(180px, 40vw);
  max-width: 50vw;
}

#gameOver {
  display: none;
}

.powerup-indicator {
  position: absolute;
  top: clamp(80px, 15vw, 100px);
  right: clamp(10px, 2vw, 20px);
  background: rgba(0, 0, 0, 0.8);
  padding: clamp(8px, 1.5vw, 10px);
  border-radius: 10px;
  font-size: clamp(12px, 1.8vw, 14px);
  border-left: 4px solid #f1c40f;
  max-width: min(200px, 40vw);
}

/* Mobil t√°mogat√°s - extra kis k√©perny≈ëk */
@media (max-width: 480px) {
  #hud {
    top: 5px;
    left: 5px;
    padding: 8px 12px;
    min-width: calc(100vw - 20px);
    max-width: calc(100vw - 20px);
  }
  
  #speedometer {
    display: none;
  }
  
  #shopBtn {
    top: auto;
    bottom: 80px;
    right: 10px;
    transform: none;
    font-size: 18px;
    padding: 10px 15px;
  }
  
  #pauseBtn {
    top: 5px;
    right: 5px;
    font-size: 20px;
    padding: 6px 10px;
  }
  
  .stat {
    min-width: calc(50vw - 30px);
  }
}

/* Nagyon magas k√©perny≈ëk */
@media (min-height: 1000px) {
  #shopBtn {
    top: 60%;
  }
}

/* Alacsony sz√©les k√©perny≈ëk */
@media (max-height: 500px) and (min-width: 768px) {
  #hud {
    top: 5px;
    padding: 6px 10px;
    font-size: 12px;
  }
  
  #controls {
    bottom: 5px;
    padding: 8px;
    font-size: 11px;
  }
  
  #shopBtn {
    padding: 6px 10px;
    font-size: 16px;
  }
}

/* Touch eszk√∂z√∂k */
@media (hover: none) and (pointer: coarse) {
  button:hover, #shopBtn:hover, #pauseBtn:hover {
    transform: none;
  }
  
  button:active, #shopBtn:active, #pauseBtn:active {
    transform: scale(0.95);
  }
}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="hud">
  <div>üí∞ <span id="moneyTxt">0</span> | ‚ö° <span id="speedTxt">0</span> km/h | üèÜ <span id="recordTxt">0</span></div>
  <div>üöó <span id="levelTxt">1</span> | üèÅ <span id="distanceTxt">0</span>m | ‚ù§Ô∏è <span id="healthTxt">1/1</span></div>
</div>

<button id="shopBtn" style="display:none">üõí BOLT</button>
<button id="pauseBtn" style="display:none">‚è∏Ô∏è</button>

<div id="controls">
  <strong>Irr√°ny√≠t√°s:</strong> W/‚Üë: Fel | S/‚Üì: Le | A/‚Üê: Bal | D/‚Üí: Jobb | P: Sz√ºnet
</div>

<!-- MEN√ú -->
<div id="menu" class="overlay">
  <h1>üöó ENDLESS AUT√ìVERSENY üèÅ</h1>
  <p>Menj min√©l messzebb, ker√ºlj az ellenfeleket √©s gy≈±jts p√©nzt a fejleszt√©sekre!</p>
  
  <div class="stats">
    <div class="stat">
      <h3>üèÜ Rekord</h3>
      <p id="menuRecord">0 m</p>
    </div>
    <div class="stat">
      <h3>üí∞ Legt√∂bb p√©nz</h3>
      <p id="menuMoney">0</p>
    </div>
  </div>
  
  <label for="laneSel">S√°vok sz√°ma (csak p√°ros):</label>
  <select id="laneSel">
    <option value="2">2</option>
    <option value="4" selected>4</option>
    <option value="6">6</option>
    <option value="8">8</option>
  </select>
  
  <label for="carColor">Aut√≥ sz√≠ne:</label>
  <input type="color" id="carColor" value="#ff0000">
  
  <label for="difficulty">Neh√©zs√©g:</label>
  <select id="difficulty">
    <option value="easy">K√∂nny≈±</option>
    <option value="normal" selected>Norm√°l</option>
    <option value="hard">Neh√©z</option>
  </select>
  
  <button onclick="startGame()">J√ÅT√âK IND√çT√ÅSA</button>
  <button onclick="showInstructions()">√öTMUTAT√ì</button>
</div>

<!-- SHOP -->
<div id="shop" class="overlay" style="display:none">
  <h2>üõí FEJLESZT√âSEK</h2>
  <p>üí∞ P√©nz: <span id="shopMoney">0</span></p>
  
  <div class="shop-item">
    <h3>üöÄ Sebess√©g</h3>
    <p>Jelenleg: <span id="currentSpeed">5</span> (Max: 20)</p>
    <div class="upgrade-bar">
      <div id="speedBar" class="upgrade-fill" style="width:25%"></div>
    </div>
    <button onclick="buyUpgrade('speed')" id="speedBtn">+1 Sebess√©g - 500$</button>
  </div>
  
  <div class="shop-item">
    <h3>‚ö° Gyorsul√°s</h3>
    <p>Jelenleg: <span id="currentAccel">0.2</span> (Max: 0.8)</p>
    <div class="upgrade-bar">
      <div id="accelBar" class="upgrade-fill" style="width:25%"></div>
    </div>
    <button onclick="buyUpgrade('accel')" id="accelBtn">+0.1 Gyorsul√°s - 400$</button>
  </div>
  
  <div class="shop-item">
    <h3>üß≠ Ir√°ny√≠t√°s</h3>
    <p>Jelenleg: <span id="currentHandling">5</span> (Max: 20)</p>
    <div class="upgrade-bar">
      <div id="handlingBar" class="upgrade-fill" style="width:25%"></div>
    </div>
    <button onclick="buyUpgrade('handling')" id="handlingBtn">+1 Ir√°ny√≠t√°s - 300$</button>
  </div>
  
  <div class="shop-item">
    <h3>üõ°Ô∏è √âlet</h3>
    <p>Jelenleg: <span id="currentHealth">1</span> (Max: 5)</p>
    <div class="upgrade-bar">
      <div id="healthBar" class="upgrade-fill" style="width:20%"></div>
    </div>
    <button onclick="buyUpgrade('health')" id="healthBtn">+1 √âlet - 800$</button>
  </div>
  
  <button onclick="closeShop()">VISSZA A J√ÅT√âKHOZ</button>
</div>

<!-- √öTMUTAT√ì -->
<div id="instructions" class="overlay" style="display:none">
  <h2>üéÆ √öTMUTAT√ì</h2>
  <div style="text-align:left; max-width: min(600px, 90vw);">
    <p><strong>üéØ C√©l:</strong> Menj min√©l messzebb an√©lk√ºl, hogy √ºtk√∂zn√©l m√°s aut√≥kkal!</p>
    <p><strong>üéÆ Ir√°ny√≠t√°s:</strong></p>
    <ul>
      <li>W / FELFEL√â NY√çL - Felfel√© mozgat√°s (√∫t mozg√°sa)</li>
      <li>S / LEFEL√â NY√çL - Lefel√© mozgat√°s (l√°sd h√°tramenet)</li>
      <li>A / BALRA NY√çL - Balra mozgat√°s</li>
      <li>D / JOBBRA NY√çL - Jobbra mozgat√°s</li>
      <li>P - Sz√ºnet (m≈±k√∂dik!)</li>
    </ul>
    <p><strong>üìù Fontos:</strong> H√°tramenet limit√°lva van, nem lehet extr√©m sebess√©ggel tolatni!</p>
    <p><strong>üí∞ P√©nz:</strong> Kapj 5$-t minden aut√≥ el≈ël sikeresen elhaladva.</p>
    <p><strong>üõí Bolt:</strong> Gy≈±jt√∂tt p√©nzb≈ël v√°s√°rolj fejleszt√©seket a jobb teljes√≠tm√©ny√©rt.</p>
    <p><strong>üö® Neh√©zs√©g:</strong> Min√©l t√∂bb s√°v, ann√°l nehezebb elker√ºlni az aut√≥kat.</p>
  </div>
  <button onclick="closeInstructions()">VISSZA</button>
</div>

<!-- J√ÅT√âK V√âGE -->
<div id="gameOver" class="overlay" style="display:none">
  <h2>üí• J√ÅT√âK V√âGE!</h2>
  <p>√útk√∂zt√©l egy m√°sik aut√≥val.</p>
  <div class="stats">
    <div class="stat">
      <h3>üèÅ T√°vols√°g</h3>
      <p id="finalDistance">0 m</p>
    </div>
    <div class="stat">
      <h3>üí∞ Megszerzett p√©nz</h3>
      <p id="finalMoney">0</p>
    </div>
    <div class="stat">
      <h3>üèÜ Rekord</h3>
      <p id="finalRecord">0 m</p>
    </div>
  </div>
  <button onclick="restartGame()">√öJ J√ÅT√âK</button>
  <button onclick="goToMenu()">F≈êMEN√ú</button>
</div>

<!-- POWERUP INDICATOR -->
<div id="powerupIndicator" class="powerup-indicator" style="display:none">
  <div id="powerupText"></div>
  <div id="powerupTimer"></div>
</div>

<script>
// =========== KONSTANSSOK √âS V√ÅLTOZ√ìK ===========
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// V√°ltoz√≥k a dinamikus m√©retez√©shez
let canvasWidth = 0;
let canvasHeight = 0;
let baseRoadWidth = 0;
let baseLaneWidth = 0;

// K√©perny≈ë m√©retez√©s
function resize() {
  canvasWidth = window.innerWidth;
  canvasHeight = window.innerHeight;
  
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  
  // √ötm√©retek √∫jrasz√°mol√°sa
  recalculateRoadDimensions();
  
  console.log(`Canvas √°tm√©retezve: ${canvasWidth}x${canvasHeight}`);
}

// √ötm√©retek √∫jrasz√°mol√°sa
function recalculateRoadDimensions() {
  // Az √∫t sz√©less√©ge a k√©perny≈ë sz√©less√©g√©t≈ël f√ºgg
  baseRoadWidth = Math.max(300, Math.min(800, canvasWidth * 0.8));
  roadWidth = baseRoadWidth;
  
  // S√°vsz√©less√©g sz√°m√≠t√°sa
  laneWidth = roadWidth / lanes;
  baseLaneWidth = laneWidth;
  
  // √öt poz√≠ci√≥ja (k√∂z√©pre igaz√≠tva)
  roadX = (canvasWidth - roadWidth) / 2;
  
  console.log(`√ötm√©retek: roadWidth=${roadWidth}, laneWidth=${laneWidth}, lanes=${lanes}`);
}

// Resize esem√©ny figyel√©se
window.addEventListener("resize", resize);

// Billenty≈±zet kezel√©s
const keys = {};
let pausePressed = false;

window.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  keys[key] = true;
  
  if (key === 'p' && !pausePressed) {
    pausePressed = true;
    setTimeout(() => { pausePressed = false; }, 200);
    togglePause();
    e.preventDefault();
  }
});

window.addEventListener("keyup", e => {
  keys[e.key.toLowerCase()] = false;
});

// J√°t√©k √°llapot
let gameRunning = false;
let gamePaused = false;
let gameOver = false;
let gameLoopId = null;

// P√©nz √©s pontsz√°m
let money = 0;
let score = 0;
let distance = 0;
let level = 1;
let record = parseInt(localStorage.getItem("record")) || 0;
let maxMoney = parseInt(localStorage.getItem("maxMoney")) || 0;

// J√°t√©kos - MEGV√ÅLTOZTATOTT √âRT√âKEK
const player = {
  x: 0,
  y: 0,
  width: 44,
  height: 76,
  speed: 0,
  maxSpeed: 5, // Kezdeti sebess√©g
  acceleration: 0.2, // Kezdeti gyorsul√°s
  handling: 5, // Kezdeti ir√°ny√≠t√°s
  color: "#ff0000",
  health: 1,
  maxHealth: 1,
  nitro: false,
  nitroTime: 0,
  shield: false,
  shieldTime: 0,
  invincible: false,
  invincibleTime: 0,
  velocityX: 0,
  velocityY: 0,
  roadOffset: 0 // Az √∫t mozg√°sa
};

// √öt v√°ltoz√≥k
let lanes = 4;
let laneWidth = 0;
let roadWidth = 0;
let roadX = 0;
let difficulty = "normal";

// Ellens√©gek
let enemies = [];
let enemySpawnTimer = 0;
let enemySpeed = 3;
let spawnRate = 90;

// Power-upok
let powerups = [];
let powerupSpawnTimer = 0;

// H√°tt√©r
let backgroundOffset = 0;
let timeOfDay = 0;

// =========== INICIALIZ√ÅL√ÅS ===========
function init() {
  record = parseInt(localStorage.getItem("record")) || 0;
  maxMoney = parseInt(localStorage.getItem("maxMoney")) || 0;
  
  document.getElementById("menuRecord").textContent = record + " m";
  document.getElementById("menuMoney").textContent = maxMoney + " $";
  document.getElementById("recordTxt").textContent = record;
  
  gameRunning = false;
  gamePaused = false;
  gameOver = false;
  
  resize();
}

// =========== J√ÅT√âK IND√çT√ÅSA ===========
function startGame() {
  lanes = parseInt(document.getElementById("laneSel").value);
  player.color = document.getElementById("carColor").value;
  difficulty = document.getElementById("difficulty").value;
  
  switch(difficulty) {
    case "easy":
      enemySpeed = 2.5;
      spawnRate = 110;
      break;
    case "normal":
      enemySpeed = 3;
      spawnRate = 90;
      break;
    case "hard":
      enemySpeed = 3.5;
      spawnRate = 70;
      break;
  }
  
  // √ötm√©retek sz√°m√≠t√°sa
  recalculateRoadDimensions();
  
  // J√°t√©kos poz√≠ci√≥ja - a p√°lya k√∂zep√©n
  player.x = canvasWidth / 2;
  player.y = canvasHeight * 0.7; // A k√©perny≈ë als√≥ fel√©ben
  player.speed = 0;
  player.velocityX = 0;
  player.velocityY = 0;
  player.roadOffset = 0;
  player.health = player.maxHealth;
  
  // Resetelj√ºk a v√°ltoz√≥kat
  money = 0;
  score = 0;
  distance = 0;
  level = 1;
  enemies = [];
  powerups = [];
  backgroundOffset = 0;
  timeOfDay = 0;
  
  // Elrejtj√ºk a men√ºt
  document.getElementById("menu").style.display = "none";
  document.getElementById("shopBtn").style.display = "block";
  document.getElementById("pauseBtn").style.display = "block";
  
  // Friss√≠tj√ºk a HUD-ot
  updateHUD();
  
  // Elind√≠tjuk a j√°t√©kot
  gameRunning = true;
  gamePaused = false;
  gameOver = false;
  
  // J√°t√©k ciklus ind√≠t√°sa
  if (gameLoopId) {
    cancelAnimationFrame(gameLoopId);
  }
  gameLoopId = requestAnimationFrame(gameLoop);
}

// =========== J√ÅT√âK CIKLUS ===========
function gameLoop() {
  if (!gameRunning) {
    gameLoopId = null;
    return;
  }
  
  if (gamePaused || gameOver) {
    gameLoopId = requestAnimationFrame(gameLoop);
    return;
  }
  
  // K√©perny≈ë t√∂rl√©se
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  
  // H√°tt√©r rajzol√°sa
  drawBackground();
  
  // √öt rajzol√°sa
  drawRoad();
  
  // J√°t√©kos friss√≠t√©se
  updatePlayer();
  
  // Ellens√©gek friss√≠t√©se
  updateEnemies();
  
  // Power-upok friss√≠t√©se
  updatePowerups();
  
  // √útk√∂z√©s ellen≈ërz√©s
  checkCollisions();
  
  // J√°t√©k√°llapot friss√≠t√©se
  updateGameState();
  
  // HUD friss√≠t√©se
  updateHUD();
  
  // Power-up indik√°tor friss√≠t√©se
  updatePowerupIndicator();
  
  // K√∂vetkez≈ë k√©pkocka
  gameLoopId = requestAnimationFrame(gameLoop);
}

// =========== √öT RAJZOL√ÅSA ===========
function drawRoad() {
  // √öt mozgat√°sa
  player.roadOffset -= player.velocityY;
  if (player.roadOffset < -canvasHeight * 2) {
    player.roadOffset += canvasHeight * 2;
  }
  
  // Kisz√°moljuk, h√°ny szakaszt kell rajzolni (2 a k√©perny≈ën, plusz 1 f√∂l√∂tte/alatta)
  const startY = Math.floor(player.roadOffset / canvasHeight) * canvasHeight;
  
  // 3 szakasz rajzol√°sa (f√∂l√∂tte, k√∂z√©pen, alatta)
  for (let i = -1; i <= 1; i++) {
    const roadY = startY + i * canvasHeight;
    drawRoadSegment(roadY);
  }
}

function drawRoadSegment(segmentY) {
  // Sz√°m√≠tsuk ki a szegmens k√©perny≈ën bel√ºli Y poz√≠ci√≥j√°t
  const screenY = segmentY - player.roadOffset;
  
  // Csak akkor rajzoljuk, ha a k√©perny≈ën van (vagy annak k√∂zel√©ben)
  if (screenY > canvasHeight || screenY < -canvasHeight) {
    return;
  }
  
  // √öt
  ctx.fillStyle = '#333';
  ctx.fillRect(roadX, screenY, roadWidth, canvasHeight);
  
  // K√∂z√©ps≈ë vonal
  ctx.setLineDash([30, 20]);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 4;
  ctx.beginPath();
  
  const centerLineX = roadX + roadWidth / 2;
  const startY = Math.max(screenY, 0);
  const endY = Math.min(screenY + canvasHeight, canvasHeight);
  
  if (endY > startY) {
    ctx.moveTo(centerLineX, startY);
    ctx.lineTo(centerLineX, endY);
    ctx.stroke();
  }
  
  // S√°vvonalak
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  for (let i = 1; i < lanes; i++) {
    const laneX = roadX + i * laneWidth;
    ctx.beginPath();
    ctx.moveTo(laneX, startY);
    ctx.lineTo(laneX, endY);
    ctx.stroke();
  }
  
  // √öt sz√©le
  ctx.setLineDash([]);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 6;
  ctx.strokeRect(roadX, startY, roadWidth, endY - startY);
  
  // √ötvonal anim√°ci√≥
  drawRoadLines(screenY, startY, endY);
}

function drawRoadLines(segmentY, startY, endY) {
  const lineOffset = (backgroundOffset * 2) % 100;
  
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 4;
  ctx.setLineDash([20, 30]);
  
  // K√∂z√©ps≈ë s√°vvonal szaggatott vonalai
  for (let i = 0; i < lanes; i++) {
    const x = roadX + i * laneWidth + laneWidth / 2;
    
    // Csak a l√°that√≥ r√©szen rajzoljuk a vonalakat
    const firstLineY = Math.floor((startY - segmentY - lineOffset) / 100) * 100 + lineOffset + segmentY;
    
    for (let y = firstLineY; y < endY; y += 100) {
      const lineStartY = Math.max(y, startY);
      const lineEndY = Math.min(y + 50, endY);
      
      if (lineEndY > lineStartY) {
        ctx.beginPath();
        ctx.moveTo(x, lineStartY);
        ctx.lineTo(x, lineEndY);
        ctx.stroke();
      }
    }
  }
  
  ctx.setLineDash([]);
}

// =========== RAJZOL√ÅS ===========
function drawBackground() {
  backgroundOffset += Math.abs(player.velocityY);
  timeOfDay += 0.0001;
  if (timeOfDay > 2) timeOfDay = 0;
  
  const isNight = timeOfDay > 1;
  const skyColor = isNight ? '#0a0a2a' : '#87CEEB';
  
  ctx.fillStyle = skyColor;
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);
  
  if (!isNight) {
    drawClouds(backgroundOffset * 0.5);
  }
  
  if (isNight) {
    drawStars(backgroundOffset * 0.3);
  }
  
  drawMountains(backgroundOffset * 0.8);
  drawTrees(backgroundOffset);
  drawHouses(backgroundOffset);
}

function drawCar(x, y, width, height, color, isPlayer = false) {
  ctx.save();
  ctx.translate(x, y);
  
  const scale = Math.min(1, canvasWidth / 1200);
  const scaledWidth = width * scale;
  const scaledHeight = height * scale;
  
  // Aut√≥ karossz√©ria
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.roundRect(-scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight, 10 * scale);
  ctx.fill();
  
  // √úveg
  ctx.fillStyle = 'rgba(100, 150, 255, 0.6)';
  ctx.fillRect(-scaledWidth / 3, -scaledHeight / 2 + 8 * scale, scaledWidth * 0.66, 14 * scale);
  
  // F√©nyek
  const lightColor = isPlayer && player.nitro ? '#ff9900' : '#ffff00';
  ctx.fillStyle = lightColor;
  ctx.fillRect(-scaledWidth / 2 - 5 * scale, -scaledHeight / 4, 5 * scale, 8 * scale);
  ctx.fillRect(scaledWidth / 2, -scaledHeight / 4, 5 * scale, 8 * scale);
  
  // Stoppf√©ny
  ctx.fillStyle = '#ff0000';
  ctx.fillRect(-scaledWidth / 2 - 5 * scale, scaledHeight / 4, 5 * scale, 8 * scale);
  ctx.fillRect(scaledWidth / 2, scaledHeight / 4, 5 * scale, 8 * scale);
  
  // Pajzs
  if (isPlayer && player.shield) {
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 3 * scale;
    ctx.beginPath();
    ctx.arc(0, 0, scaledWidth / 2 + 10 * scale, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // Nitro effekt
  if (isPlayer && player.nitro) {
    ctx.fillStyle = '#ff9900';
    ctx.beginPath();
    ctx.moveTo(-scaledWidth / 4, scaledHeight / 2);
    ctx.lineTo(scaledWidth / 4, scaledHeight / 2);
    ctx.lineTo(0, scaledHeight / 2 + 20 * scale);
    ctx.closePath();
    ctx.fill();
  }
  
  // S√©rthetetlens√©g effekt
  if (isPlayer && player.invincible && Math.floor(Date.now() / 100) % 2 === 0) {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.lineWidth = 2 * scale;
    ctx.beginPath();
    ctx.arc(0, 0, scaledWidth / 2 + 5 * scale, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  ctx.restore();
}

function drawClouds(offset) {
  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
  for (let i = 0; i < 5; i++) {
    const x = (i * 300 + offset) % (canvasWidth + 300) - 150;
    const y = 50 + Math.sin(i * 0.5 + offset * 0.001) * 20;
    const size = 60 + Math.sin(i + offset * 0.002) * 20;
    
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.arc(x + size * 0.7, y - size * 0.2, size * 0.7, 0, Math.PI * 2);
    ctx.arc(x - size * 0.7, y - size * 0.2, size * 0.7, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawMountains(offset) {
  const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight * 0.5);
  gradient.addColorStop(0, '#2c3e50');
  gradient.addColorStop(1, '#34495e');
  
  ctx.fillStyle = gradient;
  
  for (let i = 0; i < 7; i++) {
    const x = (i * 200 + offset * 0.5) % (canvasWidth + 200) - 100;
    const height = 100 + Math.sin(i) * 30;
    
    ctx.beginPath();
    ctx.moveTo(x - 100, canvasHeight * 0.5);
    ctx.lineTo(x, canvasHeight * 0.5 - height);
    ctx.lineTo(x + 100, canvasHeight * 0.5);
    ctx.closePath();
    ctx.fill();
  }
}

function drawTrees(offset) {
  ctx.fillStyle = '#2d5016';
  
  for (let side = -1; side <= 1; side += 2) {
    for (let i = 0; i < 15; i++) {
      const x = (i * 80 + offset) % (canvasWidth + 80) - 40;
      const treeX = side === -1 ? x - roadWidth / 2 - 30 : x + roadWidth / 2 + 30;
      
      if (treeX < 0 || treeX > canvasWidth) continue;
      
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(treeX - 5, canvasHeight * 0.6, 10, 40);
      
      ctx.fillStyle = '#2d5016';
      ctx.beginPath();
      ctx.arc(treeX, canvasHeight * 0.6, 25, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

function drawHouses(offset) {
  for (let side = -1; side <= 1; side += 2) {
    for (let i = 0; i < 8; i++) {
      const x = (i * 150 + offset * 0.8) % (canvasWidth + 150) - 75;
      const houseX = side === -1 ? x - roadWidth / 2 - 80 : x + roadWidth / 2 + 80;
      
      if (houseX < 0 || houseX > canvasWidth) continue;
      
      ctx.fillStyle = '#c19a6b';
      ctx.fillRect(houseX - 25, canvasHeight * 0.65, 50, 40);
      
      ctx.fillStyle = '#8b0000';
      ctx.beginPath();
      ctx.moveTo(houseX - 30, canvasHeight * 0.65);
      ctx.lineTo(houseX, canvasHeight * 0.6);
      ctx.lineTo(houseX + 30, canvasHeight * 0.65);
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(houseX - 15, canvasHeight * 0.67, 10, 10);
      ctx.fillRect(houseX + 5, canvasHeight * 0.67, 10, 10);
    }
  }
}

function drawStars(offset) {
  ctx.fillStyle = '#ffffff';
  
  for (let i = 0; i < 50; i++) {
    const x = (i * 37 + offset) % canvasWidth;
    const y = (i * 23) % (canvasHeight * 0.5);
    const size = 1 + Math.sin(i + offset * 0.01) * 0.5;
    
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawPowerup(x, y, type) {
  ctx.save();
  ctx.translate(x, y);
  
  let color, symbol;
  
  switch(type) {
    case 'nitro':
      color = '#ff9900';
      symbol = 'üöÄ';
      break;
    case 'shield':
      color = '#00ffff';
      symbol = 'üõ°Ô∏è';
      break;
    case 'coin':
      color = '#ffd700';
      symbol = 'üí∞';
      break;
    case 'health':
      color = '#ff0000';
      symbol = '‚ù§Ô∏è';
      break;
  }
  
  const scale = Math.min(1, canvasWidth / 1200);
  const size = 20 * scale;
  
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(0, 0, size, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.font = `${20 * scale}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#000';
  ctx.fillText(symbol, 0, 2 * scale);
  
  const pulse = Math.sin(Date.now() * 0.01) * 3 * scale;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2 * scale;
  ctx.beginPath();
  ctx.arc(0, 0, size + pulse, 0, Math.PI * 2);
  ctx.stroke();
  
  ctx.restore();
}

// =========== J√ÅT√âKOS KEZEL√âS - MEGV√ÅLTOZTATOTT ===========
function updatePlayer() {
  let targetVelocityX = 0;
  let targetVelocityY = 0;
  
  // Balra-jobbra mozg√°s - √âRZ√âKENYEBB
  if (keys.a || keys.arrowleft) {
    targetVelocityX = -player.handling * 1.5; // 50%-kal gyorsabb
  }
  if (keys.d || keys.arrowright) {
    targetVelocityX = player.handling * 1.5; // 50%-kal gyorsabb
  }
  
  // Fel-le mozg√°s - √âRZ√âKENYEBB
  if (keys.w || keys.arrowup) {
    targetVelocityY = -player.handling * 2.0; // 100%-kal gyorsabb
  }
  if (keys.s || keys.arrowdown) {
    targetVelocityY = Math.min(player.handling * 1.0, 1.0); // 100%-kal gyorsabb, de limit√°lva
  }
  
  // SIM√ÅBB INTERPOL√ÅCI√ì - gyorsabb reag√°l√°s
  player.velocityX += (targetVelocityX - player.velocityX) * 0.15; // 0.1 helyett 0.15
  player.velocityY += (targetVelocityY - player.velocityY) * 0.15; // 0.1 helyett 0.15
  
  // Poz√≠ci√≥ friss√≠t√©se
  player.x += player.velocityX;
  
  // J√°t√©kos korl√°toz√°sa az √∫t sz√©l√©hez (X tengely)
  const minX = roadX + laneWidth / 2;
  const maxX = roadX + roadWidth - laneWidth / 2;
  player.x = Math.max(minX, Math.min(maxX, player.x));
  
  // J√°t√©kos Y poz√≠ci√≥j√°t fixen tartjuk a k√©perny≈ë als√≥ fel√©ben
  player.y = canvasHeight * 0.7;
  
  // Sebess√©g kisz√°m√≠t√°sa - val√≥sabb sebess√©g
  player.speed = Math.sqrt(player.velocityX * player.velocityX + player.velocityY * player.velocityY) * 25; // 15 helyett 25
  
  // Nitro kezel√©se - er≈ësebb nitro
  if (player.nitro) {
    player.nitroTime--;
    if (player.nitroTime <= 0) {
      player.nitro = false;
    } else {
      // Nitro hat√°sa: sokkal er≈ësebb gyorsul√°s
      player.velocityY *= 1.1; // 1.05 helyett 1.1
      player.velocityX *= 1.1; // X ir√°nyban is gyors√≠t
    }
  }
  
  // Pajzs kezel√©se
  if (player.shield) {
    player.shieldTime--;
    if (player.shieldTime <= 0) {
      player.shield = false;
    }
  }
  
  // S√©rthetetlens√©g kezel√©se
  if (player.invincible) {
    player.invincibleTime--;
    if (player.invincibleTime <= 0) {
      player.invincible = false;
    }
  }
  
  // Aut√≥ rajzol√°sa
  drawCar(player.x, player.y, player.width, player.height, player.color, true);
}

// =========== ELLENS√âGEK KEZEL√âSE ===========
function updateEnemies() {
  enemySpawnTimer++;
  if (enemySpawnTimer > spawnRate) {
    spawnEnemy();
    enemySpawnTimer = 0;
    
    // Neh√©zs√©g n√∂vel√©se
    if (distance % 1000 === 0 && spawnRate > 40) {
      spawnRate -= 5;
      enemySpeed += 0.1;
    }
  }
  
  for (let i = enemies.length - 1; i >= 0; i--) {
    const enemy = enemies[i];
    
    // Ellenf√©l poz√≠ci√≥j√°nak friss√≠t√©se
    enemy.y -= player.velocityY; // √öttal egy√ºtt mozog
    enemy.y += enemySpeed; // Ellenf√©l saj√°t sebess√©ge
    
    // Ellenf√©l k√©perny≈ën bel√ºli poz√≠ci√≥ja
    const enemyScreenY = enemy.y - player.roadOffset;
    
    // Ellen≈ërizz√ºk, hogy az ellenf√©l m√©g a k√©perny≈ën van-e
    const isVisible = enemyScreenY > -100 && enemyScreenY < canvasHeight + 100;
    
    if (isVisible) {
      drawCar(enemy.x, enemyScreenY, enemy.width, enemy.height, enemy.color);
      
      // Ellenf√©l √°tad√°sa ellen≈ërz√©se - KEVESEBB P√âNZ
      if (!enemy.passed && enemyScreenY > player.y + player.height / 2) {
        enemy.passed = true;
        money += 5; // 10 helyett 5
        addScore(5); // 10 helyett 5
        createFloatingText(enemy.x, enemyScreenY, "+5$", "#ffd700");
      }
      
      // Ellenf√©l oldalir√°ny√∫ mozg√°sa
      if (enemy.swerve) {
        enemy.x += enemy.swerveSpeed;
        const minX = roadX + laneWidth / 2;
        const maxX = roadX + roadWidth - laneWidth / 2;
        
        if (enemy.x < minX || enemy.x > maxX) {
          enemy.swerveSpeed *= -1;
          enemy.x = Math.max(minX, Math.min(maxX, enemy.x));
        }
      }
    }
    
    // Ha az ellenf√©l elhagyta a p√°ly√°t (t√∫l lent van), t√∂r√∂lj√ºk
    if (enemy.y > player.roadOffset + canvasHeight * 2) {
      enemies.splice(i, 1);
    }
  }
}

function spawnEnemy() {
  // V√°lasztunk egy random s√°vot
  const lane = Math.floor(Math.random() * lanes);
  const x = roadX + lane * laneWidth + laneWidth / 2;
  
  // Ellenf√©l l√©trehoz√°sa a j√°t√©kos felett (√∫ton k√≠v√ºl)
  const spawnY = player.roadOffset - 100 - Math.random() * 200;
  
  const colors = ['#3498db', '#2ecc71', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c'];
  const color = colors[Math.floor(Math.random() * colors.length)];
  
  const enemy = {
    x,
    y: spawnY, // Abszol√∫t Y poz√≠ci√≥
    width: 44,
    height: 76,
    color,
    passed: false,
    swerve: Math.random() > 0.7,
    swerveSpeed: (Math.random() - 0.5) * 2
  };
  
  enemies.push(enemy);
}

// =========== POWER-UPOK ===========
function updatePowerups() {
  powerupSpawnTimer++;
  if (powerupSpawnTimer > 300 && Math.random() < 0.01) {
    spawnPowerup();
    powerupSpawnTimer = 0;
  }
  
  for (let i = powerups.length - 1; i >= 0; i--) {
    const powerup = powerups[i];
    
    // Power-up poz√≠ci√≥j√°nak friss√≠t√©se
    powerup.y -= player.velocityY; // √öttal egy√ºtt mozog
    powerup.y += 2; // Lass√∫ lefel√© mozg√°s
    
    // Power-up k√©perny≈ën bel√ºli poz√≠ci√≥ja
    const powerupScreenY = powerup.y - player.roadOffset;
    
    // Ellen≈ërizz√ºk, hogy a power-up m√©g a k√©perny≈ën van-e
    const isVisible = powerupScreenY > -50 && powerupScreenY < canvasHeight + 50;
    
    if (isVisible) {
      drawPowerup(powerup.x, powerupScreenY, powerup.type);
      
      // √útk√∂z√©s ellen≈ërz√©s j√°t√©kossal
      const dx = player.x - powerup.x;
      const dy = player.y - powerupScreenY;
      const distanceToPlayer = Math.sqrt(dx * dx + dy * dy);
      
      if (distanceToPlayer < 30) {
        collectPowerup(powerup);
        powerups.splice(i, 1);
      }
    }
    
    // Ha a power-up elhagyta a p√°ly√°t, t√∂r√∂lj√ºk
    if (powerup.y > player.roadOffset + canvasHeight * 2) {
      powerups.splice(i, 1);
    }
  }
}

function spawnPowerup() {
  // V√°lasztunk egy random s√°vot
  const lane = Math.floor(Math.random() * lanes);
  const x = roadX + lane * laneWidth + laneWidth / 2;
  
  // Power-up l√©trehoz√°sa a j√°t√©kos felett
  const spawnY = player.roadOffset - 50;
  
  const types = ['nitro', 'shield', 'coin', 'health'];
  const weights = [0.3, 0.3, 0.3, 0.1];
  let rand = Math.random();
  let typeIndex = 0;
  
  for (let i = 0; i < weights.length; i++) {
    rand -= weights[i];
    if (rand <= 0) {
      typeIndex = i;
      break;
    }
  }
  
  const powerup = {
    x,
    y: spawnY, // Abszol√∫t Y poz√≠ci√≥
    type: types[typeIndex]
  };
  
  powerups.push(powerup);
}

function collectPowerup(powerup) {
  switch(powerup.type) {
    case 'nitro':
      player.nitro = true;
      player.nitroTime = 300;
      createFloatingText(player.x, player.y, "NITRO!", "#ff9900");
      break;
      
    case 'shield':
      player.shield = true;
      player.shieldTime = 450;
      createFloatingText(player.x, player.y, "PAJZS!", "#00ffff");
      break;
      
    case 'coin':
      const coinAmount = 25 + Math.floor(Math.random() * 25); // Kevesebb p√©nz
      money += coinAmount;
      addScore(coinAmount);
      createFloatingText(player.x, player.y, `+${coinAmount}$`, "#ffd700");
      break;
      
    case 'health':
      if (player.health < player.maxHealth) {
        player.health++;
        createFloatingText(player.x, player.y, "+1 √âLET", "#ff0000");
        document.getElementById("healthTxt").textContent = `${player.health}/${player.maxHealth}`;
      } else {
        money += 15; // Kevesebb p√©nz
        createFloatingText(player.x, player.y, "+15$", "#ffd700");
      }
      break;
  }
}

// =========== √úTK√ñZ√âSEK ===========
function checkCollisions() {
  if (player.invincible) return;
  
  for (const enemy of enemies) {
    const enemyScreenY = enemy.y - player.roadOffset;
    const dx = player.x - enemy.x;
    const dy = player.y - enemyScreenY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const collisionDistance = (player.width + enemy.width) / 2 * 0.7;
    
    if (distance < collisionDistance) {
      if (player.shield) {
        player.shield = false;
        player.shieldTime = 0;
        player.invincible = true;
        player.invincibleTime = 60;
        
        createExplosion(enemy.x, enemyScreenY);
        enemies.splice(enemies.indexOf(enemy), 1);
        createFloatingText(player.x, player.y, "PAJZS T√ñRVE", "#00ffff");
        return;
      }
      
      player.health--;
      player.invincible = true;
      player.invincibleTime = 120;
      
      createExplosion(player.x, player.y);
      
      if (player.health <= 0) {
        endGame();
      } else {
        createFloatingText(player.x, player.y, `-1 √âLET (${player.health} maradt)`, "#ff0000");
        document.getElementById("healthTxt").textContent = `${player.health}/${player.maxHealth}`;
      }
      
      break;
    }
  }
}

// =========== J√ÅT√âK√ÅLLAPOT ===========
function updateGameState() {
  if (player.velocityY < 0) {
    distance += Math.abs(player.velocityY) * 2;
  }
  
  const newLevel = Math.floor(distance / 10000) + 1;
  if (newLevel > level) {
    level = newLevel;
    createFloatingText(canvasWidth / 2, canvasHeight / 2, `SZINT ${level}!`, "#2ecc71");
    
    money += level * 5; // Kevesebb p√©nz szintl√©p√©skor
    addScore(level * 25); // Kevesebb pont
  }
  
  if (distance > record) {
    record = distance;
    localStorage.setItem("record", Math.floor(record));
  }
  
  if (money > maxMoney) {
    maxMoney = money;
    localStorage.setItem("maxMoney", maxMoney);
  }
}

// =========== EFFEKTEK ===========
function createFloatingText(x, y, text, color) {
  ctx.save();
  ctx.font = `bold ${Math.max(16, canvasWidth / 40)}px Arial`;
  ctx.fillStyle = color;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x, y);
  ctx.restore();
}

function createExplosion(x, y) {
  for (let i = 0; i < 8; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 2;
    const size = 3 + Math.random() * 7;
    
    ctx.save();
    ctx.translate(x, y);
    
    ctx.fillStyle = `rgba(255, ${100 + Math.random() * 155}, 0, 0.8)`;
    ctx.beginPath();
    ctx.arc(
      Math.cos(angle) * speed * 5,
      Math.sin(angle) * speed * 5,
      size,
      0,
      Math.PI * 2
    );
    ctx.fill();
    
    ctx.restore();
  }
}

// =========== BOLT - DR√ÅG√ÅBB FEJLESZT√âSEK ===========
function openShop() {
  gamePaused = true;
  document.getElementById("shop").style.display = "flex";
  updateShop();
}

function closeShop() {
  gamePaused = false;
  document.getElementById("shop").style.display = "none";
}

function updateShop() {
  document.getElementById("shopMoney").textContent = money;
  
  // Sebess√©g - maximum 20, √°ra 500$
  const speedPercent = (player.maxSpeed - 5) / 15 * 100;
  document.getElementById("speedBar").style.width = speedPercent + "%";
  document.getElementById("currentSpeed").textContent = player.maxSpeed;
  document.getElementById("speedBtn").disabled = player.maxSpeed >= 20 || money < 500;
  document.getElementById("speedBtn").textContent = 
    player.maxSpeed >= 20 ? "MAX SZINT" : `+1 Sebess√©g - 500$`;
  
  // Gyorsul√°s - maximum 0.8, √°ra 400$
  const accelPercent = (player.acceleration - 0.2) / 0.6 * 100;
  document.getElementById("accelBar").style.width = accelPercent + "%";
  document.getElementById("currentAccel").textContent = player.acceleration.toFixed(2);
  document.getElementById("accelBtn").disabled = player.acceleration >= 0.8 || money < 400;
  document.getElementById("accelBtn").textContent = 
    player.acceleration >= 0.8 ? "MAX SZINT" : `+0.1 Gyorsul√°s - 400$`;
  
  // Ir√°ny√≠t√°s - maximum 20, √°ra 300$
  const handlingPercent = (player.handling - 5) / 15 * 100;
  document.getElementById("handlingBar").style.width = handlingPercent + "%";
  document.getElementById("currentHandling").textContent = player.handling;
  document.getElementById("handlingBtn").disabled = player.handling >= 20 || money < 300;
  document.getElementById("handlingBtn").textContent = 
    player.handling >= 20 ? "MAX SZINT" : `+1 Ir√°ny√≠t√°s - 300$`;
  
  // √âlet - maximum 5, √°ra 800$
  const healthPercent = (player.maxHealth - 1) / 4 * 100;
  document.getElementById("healthBar").style.width = healthPercent + "%";
  document.getElementById("currentHealth").textContent = player.maxHealth;
  document.getElementById("healthBtn").disabled = player.maxHealth >= 5 || money < 800;
  document.getElementById("healthBtn").textContent = 
    player.maxHealth >= 5 ? "MAX SZINT" : `+1 √âlet - 800$`;
}

function buyUpgrade(type) {
  switch(type) {
    case 'speed':
      if (money >= 500 && player.maxSpeed < 20) {
        money -= 500;
        player.maxSpeed++;
        player.handling++; // Sebess√©g n√∂vel√©se ir√°ny√≠t√°st is jav√≠t
      }
      break;
    case 'accel':
      if (money >= 400 && player.acceleration < 0.8) {
        money -= 400;
        player.acceleration += 0.1;
      }
      break;
    case 'handling':
      if (money >= 300 && player.handling < 20) {
        money -= 300;
        player.handling++;
      }
      break;
    case 'health':
      if (money >= 800 && player.maxHealth < 5) {
        money -= 800;
        player.maxHealth++;
        player.health = player.maxHealth;
        document.getElementById("healthTxt").textContent = `${player.health}/${player.maxHealth}`;
      }
      break;
  }
  
  updateShop();
  updateHUD();
}

// =========== HUD ===========
function updateHUD() {
  document.getElementById("moneyTxt").textContent = money;
  document.getElementById("speedTxt").textContent = Math.round(player.speed);
  document.getElementById("recordTxt").textContent = Math.floor(record);
  document.getElementById("levelTxt").textContent = level;
  document.getElementById("distanceTxt").textContent = Math.floor(distance);
  document.getElementById("healthTxt").textContent = `${player.health}/${player.maxHealth}`;
}

function updatePowerupIndicator() {
  const indicator = document.getElementById("powerupIndicator");
  const text = document.getElementById("powerupText");
  const timer = document.getElementById("powerupTimer");
  
  if (player.nitro || player.shield) {
    indicator.style.display = "block";
    
    if (player.nitro) {
      text.textContent = "üöÄ NITRO";
      timer.textContent = `‚è±Ô∏è ${Math.ceil(player.nitroTime / 60)}s`;
      indicator.style.borderLeftColor = "#ff9900";
    } else if (player.shield) {
      text.textContent = "üõ°Ô∏è PAJZS";
      timer.textContent = `‚è±Ô∏è ${Math.ceil(player.shieldTime / 60)}s`;
      indicator.style.borderLeftColor = "#00ffff";
    }
  } else {
    indicator.style.display = "none";
  }
}

// =========== J√ÅT√âK V√âGE ===========
function endGame() {
  gameOver = true;
  gameRunning = false;
  
  if (gameLoopId) {
    cancelAnimationFrame(gameLoopId);
    gameLoopId = null;
  }
  
  document.getElementById("finalDistance").textContent = Math.floor(distance) + " m";
  document.getElementById("finalMoney").textContent = money + " $";
  document.getElementById("finalRecord").textContent = Math.floor(record) + " m";
  document.getElementById("gameOver").style.display = "flex";
  
  document.getElementById("shopBtn").style.display = "none";
  document.getElementById("pauseBtn").style.display = "none";
}

function restartGame() {
  document.getElementById("gameOver").style.display = "none";
  startGame();
}

function goToMenu() {
  document.getElementById("gameOver").style.display = "none";
  document.getElementById("menu").style.display = "flex";
  document.getElementById("pauseBtn").style.display = "none";
  document.getElementById("shopBtn").style.display = "none";
  
  if (gameLoopId) {
    cancelAnimationFrame(gameLoopId);
    gameLoopId = null;
  }
}

// =========== SZ√úNET ===========
function togglePause() {
  if (!gameRunning || gameOver) return;
  
  gamePaused = !gamePaused;
  const pauseBtn = document.getElementById("pauseBtn");
  
  if (gamePaused) {
    pauseBtn.textContent = "‚ñ∂Ô∏è";
    pauseBtn.classList.add("paused");
  } else {
    pauseBtn.textContent = "‚è∏Ô∏è";
    pauseBtn.classList.remove("paused");
    
    if (!gameLoopId) {
      gameLoopId = requestAnimationFrame(gameLoop);
    }
  }
}

// =========== PONT SZ√ÅM√çT√ÅS ===========
function addScore(amount) {
  score += amount;
}

// =========== √öTMUTAT√ì ===========
function showInstructions() {
  document.getElementById("menu").style.display = "none";
  document.getElementById("instructions").style.display = "flex";
}

function closeInstructions() {
  document.getElementById("instructions").style.display = "none";
  document.getElementById("menu").style.display = "flex";
}

// =========== IND√çT√ÅS ===========
window.addEventListener("load", init);

// Gombok esem√©nykezel≈ëi
document.getElementById("shopBtn").addEventListener("click", openShop);
document.getElementById("pauseBtn").addEventListener("click", togglePause);

// Eg√©rkattint√°sra is m≈±k√∂dj√∂n a sz√ºnet
document.getElementById("pauseBtn").addEventListener("mousedown", function(e) {
  e.preventDefault();
});

// Az ablak blokkol√≥d√°sa eset√©n automatikus sz√ºnet
document.addEventListener("visibilitychange", function() {
  if (document.hidden && gameRunning && !gamePaused && !gameOver) {
    gamePaused = true;
    document.getElementById("pauseBtn").textContent = "‚ñ∂Ô∏è";
    document.getElementById("pauseBtn").classList.add("paused");
  }
});

// Az ablak √°tm√©retez√©se ut√°n is helyre√°ll√≠tjuk a j√°t√©kot
let resizeTimeout;
window.addEventListener("resize", function() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(function() {
    if (gameRunning && !gamePaused && !gameOver) {
      // √öjrasz√°moljuk a p√°lya poz√≠ci√≥kat
      recalculateRoadDimensions();
      
      // Friss√≠tj√ºk az ellens√©gek poz√≠ci√≥j√°t
      enemies.forEach(enemy => {
        const lane = Math.floor((enemy.x - roadX) / laneWidth);
        enemy.x = roadX + lane * laneWidth + laneWidth / 2;
      });
      
      // Friss√≠tj√ºk a power-upok poz√≠ci√≥j√°t
      powerups.forEach(powerup => {
        const lane = Math.floor((powerup.x - roadX) / laneWidth);
        powerup.x = roadX + lane * laneWidth + laneWidth / 2;
      });
      
      // J√°t√©kos poz√≠ci√≥j√°nak korrig√°l√°sa
      const lane = Math.floor((player.x - roadX) / laneWidth);
      player.x = roadX + lane * laneWidth + laneWidth / 2;
      
      console.log("√Åtm√©retez√©s ut√°n j√°t√©k √°llapot friss√≠tve");
    }
  }, 250);
});
</script>
</body>
</html>
